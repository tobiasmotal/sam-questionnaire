<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SAM Questionnaire</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
      background-color: darkkhaki;
    }
    .hidden {
      display: none;
    }
    .scale-box {
      border: 2px solid #444;   /* dark border */
      border-radius: 12px;      /* rounded corners */
      padding: 15px;            /* spacing inside the box */
      margin: 20px 0;           /* spacing between boxes */
      text-align: center;       /* center images */
      background-color: #fafafa; /* light background */
      box-shadow: 0 2px 8px rgba(0,0,0,0.1); /* subtle shadow */
    }

    .scale-box img {
      width: 80px;
      border: 3px solid transparent;
      cursor: pointer;
      border-radius: 10px;
    }
    .scale-box img.selected {
      border-color: blue;
    }
    button {
      padding: 10px 20px;
      font-size: 18px;
      margin-top: 20px;
    }
  </style>
</head>
<body>

  <!-- Launch Screen -->
  <div id="launch-screen" class="screen">
    <h1>Bus Emulator HMI</h1>
    <p>Bitte drücken Sie "Start" am Anfang der Fahrt.</p>
    <p>Please press the button "Start" at the beginning of the Ride.</p>
    <button id="start-btn" onclick="startScenario()">Start</button>
    <button id="instructions-btn" onclick="showInstructions()">Instructions</button>
  </div>

  <div id="idle-screen" class="screen hidden">
    <h1>Vielen Dank! Bitte achten Sie wieder auf die Fahrt.</h1>
    <h2>Thank you! Please shift your attention back to the ride.</h2>
  </div>

  <!-- SAM Screen -->
  <div id="sam-screen1" class="screen hidden">
    <h1>Bitte bewerten Sie Ihre Erfahrung. Wählen Sie dafür ein Bild pro Reihe.</h1>
    <h2>Please rate your experience. For that, choose one picture per line.</h2>
    <div class="scale-box" id="valence1"></div>
    <div class="scale-box" id="arousal1"></div>
    <div class="scale-box" id="dominance1"></div>
  </div>

  <div id="sam-screen2" class="screen hidden">
    <h1>Bitte bewerten Sie Ihre Erfahrung. Wählen Sie dafür ein Bild pro Reihe.</h1>
    <h2>Please rate your experience. For that, choose one picture per line.</h2>
    <div id="valence2" class="scale-box"></div>
    <div id="arousal2" class="scale-box"></div>
    <div id="dominance2" class="scale-box"></div>
  </div>

  <div id="instructions" class="screen hidden">
    <h1>Instructions</h1>
    <p>SAM-Skala misst momentane <b>emotionale Zustände.</b>
      Wählen Sie für jede Dimension ein Bild aus, das Ihre aktuelle Erfahrung am besten beschreibt.<br>
      <b>1. Valenz:</b> Wie positiv oder negativ fühlen Sie sich? / How positive or negative do you feel? <br>
      <b>2. Arousal:</b> Wie erregt oder ruhig fühlen Sie sich? / How excited or calm do you feel? <br>
      <b>3. Dominanz:</b> Wie kontrolliert oder beherrscht fühlen Sie sich? / How controlled or in control do you feel?
    </p>
    <div id="valence3" class="scale-box"></div>
    <div id="arousal3" class="scale-box"></div>
    <div id="dominance3" class="scale-box"></div>
    <button onclick="showScreen('launch-screen')">Back</button>
  </div>
  
  <div id="waiting-screen" class="screen hidden">
    <h1>Die Fahrt läuft. Bitte warten Sie...</h1>
    <h2>Ride started. Please wait...</h2>
  </div>

  <!-- End Screen -->
  <div id="end_screen" class="screen hidden">
    <h1>Vielen Dank für Ihre Teilnahme!</h1>
    <h2>Thank you for your participation!</h2>
    <button onclick="saveCSV()">Download Results</button>
    <button onclick="restartScenario()">Restart</button>
  </div>
  <!-- notification sound -->
  <audio id="notifySound" src="sounds/buzzer.wav" preload="auto"></audio>

  <!-- JavaScript to handle logic -->
  <script>
    const SAM_OPTIONS = 5;
    let scenario = 0;
    let responses = { scale1: {}, scale2: {} };
    let responses0 = { scale1: {} }; // for scenario 0

    let secondScaleReady = false;
    let firstScaleAnswered = false;
    let downloadResults = false;

    // function to restore UI state from localStorage    
    function restoreUI() {
      ["scale1","scale2"].forEach((scale, i) => {
        for (let dim in responses[scale]) {
          if (dim === "completedAt") continue;
          let value = responses[scale][dim];
          let img = document.querySelector(
            `#sam-screen${i+1} img[data-scale="${dim}"][data-value="${value}"]`
          );
          if (img) img.classList.add("selected");
        }
      });
    }

    // function to show instructions
    function showInstructions() {
      if (scenario == 0) {
        renderScales("instructions","3");
        showScreen("instructions");
      }
    }

    // function to show a specific screen and hide others
    function showScreen(id) {
      document.querySelectorAll(".screen").forEach(s => s.classList.add("hidden"));
      document.getElementById(id).classList.remove("hidden");
      localStorage.setItem("currentScreen", id);
    }

    function scheduleEvents(startTime) {
      const now = Date.now();
      const elapsed = (now - startTime) / 1000;

      if (scenario == 0) { //Baseline scenario with only one scale
        const t1 = 90;  // time for first scale
        const t2 = 180; // total scenario time
        if (elapsed >= t2) {
          if (firstScaleAnswered) {
          showScreen("end_screen");
        } 
          else {
            showScreen("sam-screen1");
          }
        } 
        else if (elapsed >= t1) {
          showScreen("sam-screen1");
          setTimeout(() => {
          if (firstScaleAnswered) {
            showScreen("end_screen");
            playNotify();
          }
          }, (t2 - elapsed) * 1000);
        } 
        else {
          showScreen("waiting-screen");
          setTimeout(() => {
          showScreen("sam-screen1");
          playNotify();
        }, (t1 - elapsed) * 1000);

        setTimeout(() => {
          if (firstScaleAnswered) {
            showScreen("end_screen");
            playNotify();
          }
        }, (t2 - elapsed) * 1000);
        }
      }
      else { // Scenarios with two scales
        const t1 = 280; // time for first scale
        const t2 = 355; // time for second scale

        if (elapsed >= t2) {
          secondScaleReady = true;
          if (firstScaleAnswered) {
            showScreen("sam-screen2");
          } else {
            showScreen("sam-screen1");
          }
        } 
        else if (elapsed >= t1) {
          showScreen("sam-screen1");
          setTimeout(() => {
            secondScaleReady = true;
            if (firstScaleAnswered) {
              showScreen("sam-screen2");
              playNotify();
            }
          }, (t2 - elapsed) * 1000);
        } 
        else {
          showScreen("waiting-screen");
          setTimeout(() => {
            showScreen("sam-screen1");
            playNotify();
          }, (t1 - elapsed) * 1000);

          setTimeout(() => {
            secondScaleReady = true;
            if (firstScaleAnswered) {
              showScreen("sam-screen2");
              playNotify();
            }
          }, (t2 - elapsed) * 1000);
        }
        }
      } // scheduleEvents
    window.addEventListener("DOMContentLoaded", () => {
       // restore responses if present
      const savedResponses = localStorage.getItem("responses");
      scenario = parseInt(localStorage.getItem("scenario")) || 0;
    
      updateButtonLabels();
      if (scenario == 0) {
        if (savedResponses) {
          responses0 = JSON.parse(savedResponses);
        }
        firstScaleAnswered = Boolean(responses0.scale1.valence && responses0.scale1.arousal && responses0.scale1.dominance);
      } 
      else {
        if (savedResponses) {
          responses = JSON.parse(savedResponses);
        }
        firstScaleAnswered = Boolean(responses.scale1.valence && responses.scale1.arousal && responses.scale1.dominance);
      }
        // rebuild scales always, but clear first to avoid duplicates
        renderScales("sam-screen1","1");
        renderScales("sam-screen2","2");

        // restore selected images
        restoreUI();

        const startTime = localStorage.getItem("scenarioStart");
        const lastScreen = localStorage.getItem("currentScreen");

        if (startTime) {
          // Always call scheduleEvents to re-establish timeouts
          scheduleEvents(parseInt(startTime));
          if(lastScreen && lastScreen !== "end_screen" && lastScreen !=="waiting-screen") {
            showScreen(lastScreen);
          }
        } else {
          showScreen("launch-screen");
        }
    });

    // Start scenario function
    function startScenario() {
      primeAudio()
      const startTime = Date.now();
      localStorage.setItem("scenarioStart", startTime);
      showScreen("waiting-screen");
      if (scenario == 0) {
        renderScales("sam-screen1","1");
      }
      else {
        renderScales("sam-screen1","1");
        renderScales("sam-screen2","2");
      }
      scheduleEvents(startTime);
    }

    // function to play notification sound
    function playNotify() {
      const audio = document.getElementById("notifySound");
      audio.pause();
      audio.currentTime = 0;
      audio.play();
    }

    // function for priming audio after interaction
    function primeAudio() {
      const audio = document.getElementById("notifySound");
      audio.play().then(() => {
      // immediately stop, but Safari now considers it unlocked
      audio.pause();
      audio.currentTime = 0;
      console.log("Audio primed for Safari.");
      }).catch(err => {
        console.log("Priming failed:", err);
      });
    }
    
    // function to update button labels based on scenario
    function updateButtonLabels() {
      const startBtn = document.getElementById("start-btn");
      if (scenario == 0) {
        startBtn.textContent = "Start Baseline";
      } else if (scenario == 1) {
        startBtn.textContent = "Start Scenario 1";
      } else if (scenario == 2) {
        startBtn.textContent = "Start Scenario 2";
      }
    }


    // function to render scales (clear first to avoid duplicates)
    function renderScales(screenId, prefix="1") {
      ["valence","arousal","dominance"].forEach(scale => {
        const container = document.getElementById(scale + prefix);
        container.innerHTML = ""; // clear previous images
        for (let i=1; i<=SAM_OPTIONS; i++) {
          let img = document.createElement("img");
          img.src = "images/" + scale + "_" + i + ".png";
          img.dataset.value = i;
          img.dataset.scale = scale;
          img.onclick = () => selectOption(prefix, scale, img);
          container.appendChild(img);
        }
      });
    }

    function selectOption(prefix, scale, img) {
      const siblings = img.parentNode.querySelectorAll("img");
      siblings.forEach(sib => sib.classList.remove("selected"));
      img.classList.add("selected");

      if (scenario == 0 && prefix === "1") {
        responses0.scale1[scale] = img.dataset.value;
        localStorage.setItem("responses", JSON.stringify(responses0));
        if (
            responses0.scale1.valence && 
            responses0.scale1.arousal && 
            responses0.scale1.dominance) {
          firstScaleAnswered = true;
          responses0.scale1.completedAt = new Date().toISOString();
          localStorage.setItem("responses", JSON.stringify(responses0));
          showScreen("idle-screen");
          // Schedule transition to end_screen at t2
          const startTime = parseInt(localStorage.getItem("scenarioStart"));
          const now = Date.now();
          const t2 = 180 * 1000; // ms
          const elapsed = now - startTime;
          const remaining = t2 - elapsed;
          if (remaining > 0) {
            setTimeout(() => {
              showScreen("end_screen");
              playNotify();
            }, remaining);
          }      
          else {
            // If t2 already passed, show end_screen immediately
            showScreen("end_screen");
            playNotify();
          }
          return;
        }
      }

      if (prefix === "1") {
        responses.scale1[scale] = img.dataset.value;
        localStorage.setItem("responses", JSON.stringify(responses));

        if (
          responses.scale1.valence &&
          responses.scale1.arousal &&
          responses.scale1.dominance
        ) {
          primeAudio() // Primes audio for second scale 
          firstScaleAnswered = true;
          responses.scale1.completedAt = new Date().toISOString();
          localStorage.setItem("responses", JSON.stringify(responses));

          if (secondScaleReady) {
            showScreen("sam-screen2");
            playNotify();
          } else {
            showScreen("idle-screen");
          }
        }
      }
      if (prefix === "2") {
        responses.scale2[scale] = img.dataset.value;
        localStorage.setItem("responses", JSON.stringify(responses));

        if (
          responses.scale2.valence &&
          responses.scale2.arousal &&
          responses.scale2.dominance
        ) {
          responses.scale2.completedAt = new Date().toISOString();
          localStorage.setItem("responses", JSON.stringify(responses));
          showScreen("end_screen");
        }
      }
    }

    function saveCSV() {
      let csv = "Scale, Timestamp, Valence, Arousal, Dominance\n";
      if (scenario == 0) {
        csv += `scale1, ${responses0.scale1.completedAt||""}, ${responses0.scale1.valence||""}, ${responses0.scale1.arousal||""}, ${responses0.scale1.dominance||""}\n`;
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "results_" + scenario + ".csv";
        a.click();
        URL.revokeObjectURL(url);
        downloadResults = true;
        localStorage.removeItem("responses0"); // <-- clear for baseline
        localStorage.removeItem("currentScreen");
        localStorage.removeItem("scenarioStart");
        return;
      }
      csv += `scale1, ${responses.scale1.completedAt||""}, ${responses.scale1.valence||""}, ${responses.scale1.arousal||""}, ${responses.scale1.dominance||""}\n`;
      csv += `scale2, ${responses.scale2.completedAt||""}, ${responses.scale2.valence||""}, ${responses.scale2.arousal||""}, ${responses.scale2.dominance||""}\n`;

      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "results_" + scenario + ".csv";
      a.click();
      URL.revokeObjectURL(url);
      downloadResults = true;
    }

    function restartScenario() {
      if (!downloadResults) {
        alert("Please download the results before restarting.");
        return;
      }
      else {
        downloadResults = false; // reset for next round
        scenario = (scenario + 1) % 3; // cycle through scenarios 0,1,2
        updateButtonLabels();
      }
      localStorage.removeItem("responses");
      localStorage.removeItem("currentScreen");
      localStorage.removeItem("scenarioStart");
      responses = { scale1: {}, scale2: {} };
      secondScaleReady = false;
      firstScaleAnswered = false;
      renderScales("sam-screen1","1");
      renderScales("sam-screen2","2");
      showScreen("launch-screen");
    }

  </script>
</body>
</html>